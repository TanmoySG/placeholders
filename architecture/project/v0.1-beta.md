# Version 0.1-Beta 

This documentation contains details about the development of Placeholders v0.1-beta.

## Scope

- Initial Minimum Requirement Setup
- Initial Design and Analysis
- Proof of Concept
- Minimum Usable API
- Basic Functionalities
- Initial Database Setup

## Features

- Basic API Setup
  - Basic Routing - no UI
- Basic Usable Flow
  - Create User Namespace (default) - Namespaces in NOT in this scope so we'd be using the term User-Default-Space instead. This default-space would become default namespace when Namespaces are introduced
  - Create a Placeholder-Container under the `User-Default-Namespace`
    - Add basic authentication for Write/Update Operations
    - Create Container passing minimum requirements
    - Only Links routing are supported - persisted files, storage, etc out of scope.
    - Can hot-swap links
    - Update/Add Links in a diferent step, not as part of creation
      - Fallback Link - out of scope
  - Get Placeholder content (placeholder->api link->resource link->content) w/o any auth
- Initially will use wunderDb
  - Will be hot-swappable with other DBs in future with generic database interfacing (TBD)

## TODOs: High Level

Design
  - Database Design
    - Database Entities
    - Database Schemas
  - Routing
    - Routes 
    - HTTP Methods
    - Request Body
    - Response Body

Usage Flow
  - Create User Account - basic authentication / no authentication
    - User's default namespace is created
    - Add userId to ACL/Authorization for Namespace 
      - Or add Authorization of `user.default-namespace` to user's authorization
  - User creates a Placeholder-Container (children to `User-Default-Namespace` by default)
    - Create Container passing minimum requirements
      - Pass Container Name
      - Returns Container ID 
    - Add Content to Placeholder-Container 
      - Patch container entity with `containerId` passing
        - Placeholder Type, only `LINK` supported
        - Placeholder Content, passing link
    - Alternately, for `LINK` type placeholder, can add Placeholder Type and Content while creating container
      - But for type `FILE` the add content would be a two step process (future scope)
    - Container ID is generated, in the format, `containerId = hash({userId}.default.{uuid})`
    - Adds `createdTimestamp` for container
  - User updates container content (link) 
    - Use Patch on Placeholder Container ID to update link
    - Updates `lastModifiedTimestamp` 
    - Requires authentication
  - Get Placeholder content 
    - Get container content using `base.url/userId/containerId`
      - Top Level routing (`base.url/containerId`) is out of scope of v0.1-beta
      - Only container content is returned, no metadata etc.


## TODOs: Low Level

Databases [out of scope for now]
  - ph-namespaces
    - only `phn-user.default-namespace`
  - ph-system
    - phs-users
      - ACL 
      - Access secrets - Username and Password (hashed)
      - Metadata (basic)
    - phs-configs
      - maybe ACL can be here (**think about this**)

JSON File-based Data Storage
- ph-namespace.json
- ph-system.json
  - access-secrets {}

Routes
  - POST `base.url/users`
    - Create User Account
    - Pass 
      - username
      - password
      - metadata
    - Return
      - User URL
      - User ID
  - POST `base.url/userId/default/containers`
    - Create Container in default-namespace
    - Pass 
      - Container Name
      - Container Content Type
      - Container Content
    - Return
      - Container ID, `containerId = hash({userId}.default.{uuid})`
  - PATCH `base.url/userId/default/containerId`
    - Update container content
    - Pass
      - Content
      - Content Type (if not done earlier)
    - Returns 
      - Updated Entitiy
  - GET `base.url/userId/default/containerId`
    - Get Container content
    - Returns
      - Content

Container (Placeholder) Ownership Levels
- User
  - Namespace
    - Container
- Hence the url format `userId/namespaceId/containerId`
- The URL `userId/default/containers` correspond to the containers in the default namespace for user
- And the URL `userId/default/containerId` corresponds to a specific container in the default namespace for user

Access Control List (ACL)
- The Access is granted on the Namespace level to the user
- A user is granted access to ONLY their namespaces (only Default initially)
- A potential ACL sample can be 

```json
{
	"user" : {
		"namespace-name" : {
			"route" : "/userId/namespaceId",
			"permissions" : {
				"GET" : {
					"requireAuth" : false
				},
				"POST" {
					"requireAuth" : true
				}
			}
		},
		"default-namespace" : {
			"route" : "/userId/default",
			"permissions" : {
				"GET" : {
					"requireAuth" : false
				}
			}
		}
	}
}
```
- A middleware shall check incoming request in the following flow
  - Check UserID, Password. 
  - Check if route (till namespace) is accessible to user
    - Check `userId.{namespace}.route` and `userId.{namespace}.permissions.{method}` 
    - Resolve request for valid else reject request.


Handled HTTP Status/Error Codes
  - 404
  - 500
  - what else?


## TODOs: Tasks

Refer to Project Board or Planning Documentation on Notion.
- [Project Board](https://github.com/users/TanmoySG/projects/15)

Tasks

- Basic Server [[#9](https://github.com/TanmoySG/placeholders/issues/9)]
  - Configurations
    - Port
    - Home Directory (data persitence)
    - Hash Algorithm
- Initial User Creation Flow (no Access Control Enforced) [[#10](https://github.com/TanmoySG/placeholders/issues/10)]
  - Check if username/email exists
  - Hash password, using SHA1/MD5
  - Generate UUID for user
  - Create Default Namespace to ph-namespaces.json
  - Add User Profile to ph-systems.users.json
  - See [this diagram](./step1-flow1.jpg)
  - Fallbacks
    - Anyone can create and access any container (no route for container access is implemented, so no harm)
- Access Control List (ACL) Utility Subpackage
  - A ACL Helper Code to create, update, delete (out of scope for v0.1-beta), and check Access for permission
  - TBD
- Access Control List : Integration
  - The Access is granted on the Namespace level to the user
  - A user is granted access to ONLY their namespaces (only Default initially)
  - Check ACL JSON Sample in ToDo: Low Level
  - Create a ACL Library/Package 
  - A middleware shall check incoming request in the following flow
    - Check UserID, Password. 
    - Check if route (till namespace) is accessible to user
      - Check `userId.{namespace}.route` and `userId.{namespace}.permissions.{method}` 
      - Resolve request for valid else reject request.
- Create Container in default namespace
  - Implement `POST base.url/userId/{namespace}/containers`
  - Create Container in default-namespace
    - Pass 
      - Container Name
      - Container Content Type
      - Container Content
    - Return
      - Container ID
  - Check if User has access
  - Container ID `containerId = hash({userId}.{namespace}.{containerName})`, 
    - use MD5/SHA1, need not be too big, max 10 characters pref.
  - Check If Container with name exists in namespace
  - Validation
  - Generate containerId
  - Push incoming data to DB
- Update Container
  - PATCH `base.url/userId/{namespace}/containerId`
    - Update container content
    - Pass
      - Content
      - Content Type (if not done earlier)
    - Returns 
      - Updated Entitiy
  - Check if User has access
  - Validate earlier and current content
  - Update in DB
  - Return updated (redact sensitive data) data
- Implement: Get Placeholder content
  - GET `base.url/userId/{namespace}/containerId`
    - Get Container content
    - Returns
      - Content
  - No auth required for time being
- Containerize (Docker) Backend
  - Create a docker container
    - docker-compose
    - dockerfile
- Shell Scripts
  - Shell scripts for running locally
  - Shell scripts for local test w/o much hassle
- Documentation & API Specs
  - Add documentation
  - Add Postman Collection for API  
  - Add sample snippets 
- Release Plan
  - Should host ?
    - Where ?
  - Should release tag
    - What CI/CD setup required ?
- Error Handling
  - other than route specific error, some general errors might also need to be handled
    - common `404` return for non existent routes, but different for `container not found`
    - What else ? TBD
- Unit Testing `EXTRA` 
  - Add unit tests 